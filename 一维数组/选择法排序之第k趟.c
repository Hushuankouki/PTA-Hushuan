//本题要求使用选择法排序，将给定的n个整数从小到大进行排序，输出第k趟（k从0开始）排序后的结果。
//
//选择排序的算法步骤如下：
//
//第0步：在未排序的n个数（a[0] ~ a[n−1]）中找到最小数，将它与 a[0]交换；
//
//第1步：在剩下未排序的n−1个数（a[1] ~ a[n−1]）中找到最小数，将它与 a[1] 交换；
//
//......
//
//第k步：在剩下未排序的n−k个数（a[k] ~ a[n−1]）中找到最小数，将它与 a[k] 交换；
//
//......
//
//第n−2步：在剩下未排序的2个数（a[n−2] ~ a[n−1]）中找到最小数，将它与 a[n−2]交换。
//
//输入格式：
//输入第一行给出一个不超过10的正整数n和一个不超过n - 1的正整数k。第二行给出n个整数，其间以空格分隔。
//
//输出格式：
//在一行中输出排序过程中第k步（k从0开始）的中间结果，即第k步后a[0] ~ a[n−1]的值，相邻数字间有一个空格，行末不得有多余空格。
//
//输入样例：
//4 1
//5 1 7 2
//
//输出样例：
//1 2 7 5

#include <stdio.h>
int a[100];
int main()
{
    int n, k;
    scanf("%d %d", &n, &k);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    for (int step = 0; step <= k; step++) {    //执行到k步
        int min = step;    //指针在k步的a[0]处
        for (int j = step + 1; j < n; j++) {    //比大小并让指针指到最小值
            if (a[min] > a[j])
                min = j;
        }
        //交换最小值到k步的a[0]处
        int z = a[step];
        a[step] = a[min];
        a[min] = z;
    }
    for (int i = 0; i < n; i++) {
        printf("%d", a[i]);
        if (i != n - 1)
            printf(" ");
    }
    return 0;
}